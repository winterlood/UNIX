유닉스 시스템 프로그래밍
===

유닉스 시스템 프로그래밍이란, 

유닉스에서 제공하는 여러가지 기능들을 시스템 호출이라는 프로그래밍 인터페이스를 이용하여, 

프로그래밍을 하는 행위를 의미한다.

> 유닉스에서 동작하는 프로그램을 작성 하려면, 기본적인 아주 간단한 프로그램을 제외하면, <br>
> 대부분은 시스템 호출을 이용해야 한다고 한다.. 

즉. 일반적인 응용 프로그램이랑은 달리, 유닉스에서 자체적으로 제공하는 시스템 호출을 사용하여,

프로그램을 작성하는 것이다.

시스템 호출
---

유닉스 시스템은 파일 시스템 접근, 사용자 정보, 시스템 정보, 시스템 시간 정보, 네트워킹 등 다양한 서비스를 제공한다.

유닉스 시스템이 제공하는 이러한 서비스를 이용해 프로그램을 작성 할 수 있도록 제공되는 프로그램이 인터페이스를 

시스템 호출 이라고 부른다. 

즉 시스템 호출이란, 유닉스 시스템에서 제공하는 다양한 서비스를 이용하여 프로그래밍을 할 수 있는 인터페이스를 의미한다.

시스템 호출의 형태
---

시스템 호출은 프로그래밍 인터페이스 이므로, 기본적인 형태는 C언어의 함수와 동일하다.

함수명처럼 시스템 호출에 사용할 이름들이 이미 정의되어있으며, 그이름을 API 쓰듯이 가져다가 쓰면 되는것 같다.

물론 함수별로, 파라미터 개수도 다르고 형태도 다를것이다.

return type은 보통 0 or 1 의 exit status code로 반환 된다.

라이브러리 함수
---

라이브러리는 미리 컴파일 된 함수들을 묶어서 제공하는 특수한 파일의 형태이다.

C언어는 데이터 입출력 
> scanf() , printf() ... etc

수학공식
>sqrt(), pow() ..etc

문자열 처리
>strcmp, strlen, strcat ... etc

등등의 응용프로그램 개발에 필요한 함수들을 유형별로 분류해 라이브러리로 제공한다.

라이브러리 함수는 라이브러리에 포함되어 있는 함수를 의미한다.

이것은 자주 사용하는 기능을 독립적으로 구현해둠으로써, 프로그램의 개발과 디버깅을 쉽게 하고,

좀더 컴파일을 빠르게 해준다.

유닉스의 library function 들은 보통 /lib나 /usr/lib에 위치한다.

일반적으로 'lib'로 이름을 시작하며, .a확장자나 .so 확장자를 갖는다.

다시말해, 미리 컴파일이 된 함수들을 묶어서 제공하는 특수한 파일의 형태이다.

동적 실행시간 형태로 제공된다.

시스템 콜 vs 라이브러리 함수
---

물론 둘다 시스템 호출을 사용하긴 한다.

그러나 시스템 콜의 경우 즉각 커널의 모듈을 호출하지만,

라이브러리 함수의 경우에는, 라이브러리 함수 내로 들어가서 함수 내부에서 시스템 콜을 사용한다.

물론 라이브러리가 시스템 콜을 사용하는 라이브러리일 경우에 그렇다.

> 결론적으로 시스템 콜은 커널의 해당 모듈을 직접 호출하여 작업하고 결과값을 직접 리턴받는다. <br>
> 라이브러리는 직접 호출하는 것이 아니다.

MAN
---

유닉스 시스템은 명령, 함수 등 시스템이 제공하는 다양한 서비스에 대한 MAN 페이지를 제공한다.

사용자는 MAN [검색 명령어] 를 통하여, MAN 페이지를 검색하고 Reference를 얻을 수 있다고 한다.
> 그냥 StackOverFlow를 보는게 더 .... 크흠

흔히들 사용하는 일반적인 명령에 관한 설명은 섹션 1에 있다고 한다.

오류처리
---

시스템 콜은 성공하면 0을 리턴, 실패하면 -1을 리턴한다.

전역변수 ERRNO에 오류코드를 저장하며, 시스템의 오류 코드는 여러가지가 존재한다.

~~~
#include <unistd.h>
#include <stdio.h>

extern int errno;

int main(void) {
	if(access("unix.txt", F_OK) == -1) {
		printf("errono=%d\n", errno);
	}

	return 0;
}
~~~

라이브러리 함수는 오류발생시 NULL을 RETURN 한다.

물론 INT형을 RETURN 하게 되어있으면 -1을 시스템 콜과 동일하게 RETURN 한다.

~~~
#include <unistd.h>
#include <stdio.h>

extern int errno;

int main(void) {
	FILE *fp;
	
	if ((fp = fopen("unix.txt", "r")) == NULL) {
		printf("errno=%d\n", errno);
		exit(1);
	}
	fclose(fp);

	return 0;
}
~~~

유닉스 시스템 도구
---

vi 같은 편집기를 이용하여 프로그래밍을 하면,

compile 이라는 작업을 거쳐야한다.

compile 이란. 텍스트로 작성된 프로그램을 시스템이 이해 할 수 있는 기계어로 변환하는 과정을 의미한다.

보통 compile 한다! 라고 하면, compile 과정과 library link 과정을 하나로 묶어서 수행하는 것을 의미한다고 한다.

다음과 같은 순서로 컴파일이 진행된다.

~~~
[test.c] -> compile -> [test.o] -> Link -> [test.o] + [printf.o] ->  실행파일 -> [a.out]
~~~

자 살펴보면, test.c 라는 프로그램을 작성했다고 하자,

이를 compile 하면 object file 인 test.o 가 생성된다. 그리고 이를 library function printf.o 와 link시켜, 

실행파일을 생성하는 것이다.

GNU C Compiler : gcc
---

프로그램을 compile 하려면, 이를 수행하는 compiler 가 설치 되어있어야 한다.

이게 gcc이다.

/usr/local/bin 디렉토리에 설치되어 있다.

MakeFile & Make
---

대부분의 프로그램을 작성할 때,

소스파일은 하나가 아닌 여러개로 구성된다.

> java 프로젝트 하나만해도... 최소 30개는 넘을것이다.

컴파일 시 이들을 묶어서 실행파일을 생성하게 되는데,

유닉스 시스템에서는 이렇게 여러가지의 소스파일들을 컴파일 하고 링크해서 실행 파일을 생성하는데 사용되는 도구를

Makefile 설정 파일과, make명령어를 제공하여 수행하게 해준다.

Makefile은 컴파일 명령, 소스파일 컴파일 방법, 링크할 파일, 실행 파일명 등을 설정하는 파일이다.

make 명령은 Makefile을 읽어 해당 파일에서 지정한대로 실제 컴파일을 실행하고 실행파일을 생성해준다.

실행파일을 한번 생성하면, 변경사항이 있는 파일만 재 컴파일 하는 똑똑한 친구이다.

